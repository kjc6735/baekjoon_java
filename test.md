## 소주제

### 1️⃣ 질의응답

> ❓ **질문**
>
> ``` 
> import java.io.*;
>
>public class Main {
>
>  public static void main(String[] args) throws IOException {
>    String str1 = "string";
>    String str2 = "string";
>    String str3 = new String("string");
>    String str4 = new StringBuilder("string").toString();
>
>    System.out.println(str1 == str2);
>    System.out.println(str2 == str3);
>    System.out.println(str3 == str4);
>    System.out.println(str1.equals(str4));
>  }
>
>}
>
> ```
>
> 
> 💬 **답변**  
> ``` 
>  결과:
> true false false true
>자바는 String을 "~~~" 형식으로 만들면 스트링풀에 저장하게 된다. 자바는 스트링을 스트링풀에 고유한 값으로 저장하게 되고, 같은 문자열이 있을 경우 그 문자열도 같은 객체를 가리킨다. 그러므로 String의 값이 같다면 ( "~~" 방식으로 만들었을 경우) 해당 객체는 같은 객체이다.
>하지만 new String("~")는 힙메모리에 올라가므로 일반 객체취급을 받는다. 
>str3 == str4가 false가 나오는 이유이다.
>String의 equals는 먼저 같은 객체인지 확인한다. (this == param) 
>그리고 같은 객체가 아니라면, 문자열을 비교하는 방식으로 설계되어 있다. 그렇기 때문에 str1.equals(str4);는 true가 나오게 된다.
> 여기에 작성해주세요.
> ```
>> ❓ **질문**
>> ``` 
>> Object의 equals와 String의 equals는 어떻게 다른가요?
>> ```
>> 💬 **답변**
>> ``` 
>> Object의 equals는 자신이 맞는지에 대해 보는 것이고, String은 자신의 객체가 맞는지를 비교하고 아니라면 내용을 비교하여 결과를 리턴한다.
>> ```
>>> ❓ **질문**
>>> ``` 
>>> 그럼 String의 경우에 == 는 자신이 맞는지를 비교한다고 했고, 스트링풀에 저장되어 같은 문자열이면 같은 객체를 가리킨다고 했습니다. 그럼 왜 equals를 사용하는건가요?
>>> ```
>>> 💬 **답변**
>>> ``` 
>>> 첫번째로는 위의 예제처럼 문자열을 생성하는 다양한 방법이 있다. 그렇기 때문에 문자열이 같은 문자열이라도 == 같은 객체가 아니므로 false가 나오는 경우가 있다. 문자열의 일치 여부를 확인하기 위해서는 equals를 사용하는 것이 좋은 방법이다. 
>>> ```

<br> 

--- 

<br> 

### 2️⃣ 질의응답

> ❓ **질문**
>
> ``` 
> 자바소스파일의 컴파일 & 실행과정에 대해 설명해주세요.
> ```
>
> 
> 💬 **답변**  
> ``` 


<br> 

--- 

<br> 

### 3️⃣ 질의응답

> ❓ **질문**
>
> ``` 
> String, StringBuilder, StringBuffer에 대해 설명해주세요.
> ```
>
> 
> 💬 **답변**  
> ``` 
> String : 불변성이기 때문에 자동적으로 thread-safe하다. 만약에 문자열을 수정한다면 새로운 객체로 만들어 반환된다.
> StringBuilder : 가변적이며, 문자열을 수정할 수 있음. 하지만 쓰레드 세이프하지 않으므로 싱글스레드에서 사용하는 것이 좋다.
> StringBuffer : 스트링빌더와 같음. 다른 점은 내부적으로 동기화 처리가 되어있어 멀티 스레드 환경에서 사용해도 안전하다. 
> ```

<br> 

--- 

<br> 

### 4️⃣ 질의응답

> ❓ **질문**
>
> ``` 
>String이 Immutable(불변)함으로 인해 얻을 수 있는 이점에는 어떤 것이 있을까요?
> ```
> 
> 💬 **답변**  
> ``` 
> String의 불변의 이점은 thread-safe하다는 것이다. 
> 사용하기 안전하다. 어떠한 곳(ex method)에서 수정을 할 수 없기 때문에, 문자열을 믿고 사용할 수 있다는 점이다.
> String을 "~~"로 만들었을 경우 같은 문자열을 가진다면, 모두 같은 객체이기 때문에 메모리를 아낄 수 있다.
> ```
> 

<br> 

--- 

<br> 

### 5️⃣ 질의응답

> ❓ **질문**
>
> ``` 
> 자바의 자료형에 대해 아는 데로 설명해주세요.
> ```
> 
> 
> 💬 **답변**  
> ``` 
> 자바는 primitive타입과 reference타입 구분된다. 
> primitive타입에는 boolean, byte, char, short,  int, long, float, double이 있다. 피리미티브 타입은 직접적인 값을 저장하고, 스택 메모리에 올라간다. 선언 시 자동으로 초기화가 된다.
> reference타입 객체의 주소를 저장한다. 크기가 동적으로 결정된다. 선언만 하고 할당하지 않으면 Null이다. 
> ```
> 


--- 

<br> 

### 6️⃣ 질의응답

> ❓ **질문**
>
> ``` 
> 추상 클래스와 인터페이스의 차이점에 대해서 말씀해주세요.
> ```
>
> 
> 💬 **답변**  
> ``` 
> 추상클래스는 맴버변수를 가질 수 있고, 구현 메서드를 가질 수 있다. 다중 상속이 불가능하다.
> 인터페이스의 경우에는 추상 메서드만을 가지고 있으며, 구현 메서드를 가질 수 없다. 하지만 자바8로 올라오면서 default 키워드를 사용하는 구현 메서드를 가질 수 있지만, 꼭 구현하지 않아도 되는 메서드이다. 다중 상속이 가능하며, 만약에 변수를 사용한다면, 무조건 static final로 사용해야 한다. 다중상속이 가능하다.


<br> 

--- 

<br> 

### 7️⃣ 질의응답

> ❓ **질문**
>
> ``` 
> 자바 컬렉션에 대해서 설명해주세요.
> ```
>
> 
> 💬 **답변**  
> ``` 
> 데이터(객체) 집합이며, 리스트와 셋, 맵이 있다. 리스트의 경우 순서가 있으며, 나머지는 순서를 보장하지 않는다. 또한 크기가 동적으로 조정 될 수 있는 특징이 있다.
> ```


<br> 

--- 

<br> 

### 8️⃣ 질의응답

> ❓ **질문**
>
> ``` 
자바에서 배열과 리스트의 차이점에 대해서 말씀해주세요.
>
> ```
>
> 
> 💬 **답변**  
> ``` 
> 배열은 고정된 크기를 가지고 있는 것에 비해 리스트는 크기가 고정되어 있지 않다.
> 그러므로 리스트는 배열의 크기를 신경 쓸 필요가 없다. 또한 리스트는 구현된 메서드를 통해 수정, 삭제, 추가가 쉽다.
> 
> ```
> 

<br> 

--- 

<br> 

### 9️⃣ 질의응답

> ❓ **질문**
>
> ``` 
객체 지향 프로그래밍의 4가지 특징에 대해서 말씀해주세요.
>
> ```
>
> 
> 💬 **답변**  
> ``` 
> 캡슐화 : 데이터를 직접 접근하는 것을 막으며
> 상속 : 이미 존재하는 클래스로부터 상속받아 새로운 클래스를 만드는 것이다.  코드의 재사용성을 높일 수다.
> 다형성 : 같은 이름의 메서드를 각 객체에서 다시 정의해, 서로 다른 클래스의 객체들이 동일한 메서드를 호출 할 수 있다.
> 추상화 : 객체의 공통된 특성과 동작을 정의하는 것으로 추상 클래스나 인터페이스를 통해 추상화랄 표현할 수 있다.
> ```
